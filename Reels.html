<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VoidUpLift Reels Editor Pro</title>

<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&family=Anton&family=Bebas+Neue&family=Playfair+Display&family=Oswald&family=Pacifico&family=Cinzel&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<style>
/* ---------- RESET & CORE ---------- */
*{ box-sizing:border-box; margin:0; padding:0; }
body{ background:#000; color:#fff; font-family:'Poppins', sans-serif; height:100vh; overflow:hidden; }
.app{ display:flex; flex-direction:column; height:100vh; max-width: 500px; margin: 0 auto; border: 1px solid #222; position: relative; }

/* ---------- PREVIEW AREA ---------- */
.preview{ 
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    padding:10px; 
    background:#111; 
    flex-shrink: 0;
}
canvas{ 
    width:auto; 
    height:35vh; 
    aspect-ratio:9/16; 
    border-radius:12px; 
    border:2px solid #333; 
    background:#000; 
    cursor: crosshair; 
    touch-action: none; 
}
.play-btn-ui{ font-size:36px; margin-top:5px; cursor:pointer; color: #00f2ea; }
#timeline { width: 90%; margin: 8px 0; accent-color: #00f2ea; cursor: pointer; height: 14px; }

/* ---------- ICON NAVIGATION ---------- */
.iconbar{ 
    display:flex; 
    justify-content:space-around; 
    padding:10px 0; 
    background:#080808; 
    border-top:1px solid #222;
}
.iconbar span{ font-size:24px; cursor:pointer; color: #666; transition: 0.3s; }
.iconbar span.active-tab { color: #00f2ea; }

/* ---------- CONTROLS AREA ---------- */
.controls{ 
    flex:1; 
    background:#080808; 
    overflow-y:auto; 
    padding:15px; 
}
.panel{ display:none; animation: fadeIn 0.2s ease; }
.panel.active{ display:block; }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

.control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }

label { display: block; margin-bottom: 4px; font-size: 10px; color: #00f2ea; text-transform: uppercase; letter-spacing: 1px; font-weight: bold; }
textarea, input[type="text"], input[type="number"], select { 
    width:100%; 
    background:#151515; 
    border:1px solid #333; 
    color:#fff; 
    padding:10px; 
    margin-bottom:12px; 
    border-radius: 6px; 
    font-size: 13px;
    font-family: inherit; 
    outline: none; 
}
input[type="range"] { width: 100%; margin-bottom: 15px; accent-color: #00f2ea; height: 12px; }
input[type="color"] { width: 100%; height: 35px; background: none; border: 1px solid #333; cursor: pointer; border-radius: 6px; }

.status-bar{ text-align:center; font-size:11px; color:#00f2ea; padding:8px; background: #050505; }

/* RENDER OVERLAY */
#renderOverlay {
    display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9); z-index: 1000; flex-direction: column; justify-content: center; align-items: center;
}
.loader { border: 4px solid #333; border-top: 4px solid #00f2ea; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
</style>
</head>

<body>

<div id="renderOverlay">
    <div class="loader"></div>
    <div id="renderProgress" style="font-weight: bold; letter-spacing: 1px;">RENDERING 0%</div>
    <div style="font-size: 10px; color: #666; margin-top: 5px;">Processing high-quality video...</div>
</div>

<div class="app">
    <div class="preview">
        <canvas id="canvas" width="1080" height="1920"></canvas>
        <div style="display:flex; align-items:center; width:100%; justify-content:center; gap:10px;">
            <span id="playBtn" class="material-icons play-btn-ui">play_circle_filled</span>
            <input type="range" id="timeline" min="0" max="17" step="0.01" value="0">
        </div>
    </div>

    <div class="iconbar">
        <span class="material-icons active-tab" onclick="showPanel('textP', this)">text_fields</span>
        <span class="material-icons" onclick="showPanel('fontP', this)">font_download</span>
        <span class="material-icons" onclick="showPanel('imgP', this)">image</span>
        <span class="material-icons" onclick="showPanel('audioP', this)">music_note</span>
        <span class="material-icons" style="color:#00f2ea" onclick="exportHQVideo()">download</span>
    </div>

    <div class="controls">
        <div id="textP" class="panel active">
            <label>Text Content</label>
            <textarea id="textInput" rows="2">VoidUpLift</textarea>
            
            <label>Font Size</label>
            <input type="range" id="fontSizeRange" min="30" max="400" value="100">
            
            <div class="control-grid">
                <div>
                    <label>Text Color</label>
                    <input type="color" id="textColorPicker" value="#ffffff">
                </div>
                <div>
                    <label>Typing Speed</label>
                    <input type="range" id="typingSpeedRange" min="5" max="60" value="20">
                </div>
            </div>
            
            <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                <input type="checkbox" id="typingToggle"> Enable Typing Effect
            </label>
        </div>

        <div id="fontP" class="panel">
            <label>Typography</label>
            <select id="fontFamilySelect" size="5">
                <option value="Poppins" selected>Poppins</option>
                <option value="Anton">Anton</option>
                <option value="Bebas Neue">Bebas Neue</option>
                <option value="Playfair Display">Playfair Display</option>
                <option value="Oswald">Oswald</option>
                <option value="Pacifico">Pacifico</option>
            </select>
            
            <label>Entrance Animation</label>
            <select id="animSelect">
                <option value="fade">Smooth Fade</option>
                <option value="slide">Cinematic Rise</option>
                <option value="pop">Pop Zoom</option>
                <option value="bounce">Bouncy</option>
            </select>
        </div>

        <div id="imgP" class="panel">
            <label>Background Image</label>
            <input type="file" id="bgUpload" accept="image/*">
            
            <label>Video Length (Seconds)</label>
            <input type="number" id="videoDuration" value="17">
        </div>

        <div id="audioP" class="panel">
            <label>Background Track</label>
            <input type="file" id="audioUpload" accept="audio/*">
        </div>
    </div>

    <div class="status-bar" id="statusMsg">Ready to create</div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d", {alpha: false});
const timeline = document.getElementById("timeline");
const statusMsg = document.getElementById("statusMsg");
const renderOverlay = document.getElementById("renderOverlay");
const renderProgress = document.getElementById("renderProgress");

let bgImg = new Image(), userAudio = null;
let textStr = "VoidUpLift", currentFont = "Poppins";
let fSize = 100, tColor = "#ffffff", totalSecs = 17;
let textX = 100, textY = 400, animationType = "fade";
let useTyping = false, typeSpeed = 20;
let currentTime = 0, isPlaying = false, lastFrameTime = 0;

function showPanel(id, iconEl) {
    document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
    document.querySelectorAll('.iconbar span').forEach(s => s.classList.remove('active-tab'));
    document.getElementById(id).classList.add('active');
    iconEl.classList.add('active-tab');
}

function updateFrame() { drawCanvas(currentTime); }

// UI Sync
textInput.oninput = e => { textStr = e.target.value; updateFrame(); };
fontSizeRange.oninput = e => { fSize = parseInt(e.target.value); updateFrame(); };
textColorPicker.oninput = e => { tColor = e.target.value; updateFrame(); };
fontFamilySelect.onchange = e => { currentFont = e.target.value; updateFrame(); };
animSelect.onchange = e => { animationType = e.target.value; updateFrame(); };
typingToggle.onchange = e => { useTyping = e.target.checked; updateFrame(); };
typingSpeedRange.oninput = e => { typeSpeed = parseInt(e.target.value); updateFrame(); };
videoDuration.oninput = e => { totalSecs = +e.target.value; timeline.max = totalSecs; updateFrame(); };
timeline.oninput = e => { currentTime = parseFloat(e.target.value); updateFrame(); };
bgUpload.onchange = e => { if(e.target.files[0]) { bgImg.src = URL.createObjectURL(e.target.files[0]); bgImg.onload = updateFrame; } };
audioUpload.onchange = e => { if(e.target.files[0]) userAudio = new Audio(URL.createObjectURL(e.target.files[0])); };

// Text Dragging logic
let isDragging = false;
canvas.onpointerdown = () => isDragging = true;
window.onpointerup = () => isDragging = false;
window.onpointermove = e => {
    if(!isDragging) return;
    const rect = canvas.getBoundingClientRect();
    textX = (e.clientX - rect.left) * (1080 / rect.width);
    textY = (e.clientY - rect.top) * (1920 / rect.height);
    updateFrame();
};

function drawCanvas(t) {
    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.fillStyle = "#000"; 
    ctx.fillRect(0,0,1080,1920);

    // IMAGE FIT LOGIC
    if(bgImg.complete && bgImg.width) {
        let ratio = Math.min(1080 / bgImg.width, 1920 / bgImg.height);
        let w = bgImg.width * ratio, h = bgImg.height * ratio;
        ctx.drawImage(bgImg, (1080-w)/2, (1920-h)/2, w, h);
    }

    // OUTRO SEQUENCE (Last 2.5 seconds)
    if (t >= totalSecs - 2.5) {
        let prog = Math.min(1, (t - (totalSecs - 2.5)) / 2.5);
        ctx.fillStyle = "#000"; ctx.globalAlpha = prog; ctx.fillRect(0,0,1080,1920);
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillStyle = "#00f2ea";
        ctx.font = `bold ${110 + prog*20}px Poppins`;
        ctx.fillText("VoidUpLift", 540, 960);
        ctx.restore(); return;
    }

    // TEXT LAYER
    ctx.save();
    let globalFade = Math.min(1, t / 1.0);
    ctx.fillStyle = tColor;
    ctx.font = `${fSize}px "${currentFont}"`;
    ctx.textAlign = "left"; ctx.textBaseline = "top";
    ctx.shadowColor = "rgba(0,0,0,0.8)"; ctx.shadowBlur = 20;

    let animProg = Math.min(1, t / 1.5);
    let dx = textX, dy = textY, sc = 1;

    // Apply Animations
    if (animationType === "slide") dy += (1 - animProg) * 150;
    if (animationType === "pop") sc = 0.5 + (animProg * 0.5);
    if (animationType === "bounce") dy += Math.abs(Math.sin(t * 4)) * -50;

    ctx.globalAlpha = animProg * globalFade;
    ctx.translate(dx, dy);
    ctx.scale(sc, sc);

    let displayStr = useTyping ? textStr.slice(0, Math.floor(t * typeSpeed)) : textStr;
    let words = displayStr.split(" "), line = "", yOffset = 0;
    for (let w of words) {
        let test = line + w + " ";
        if (ctx.measureText(test).width > 900) { 
            ctx.fillText(line, 0, yOffset); 
            line = w + " "; 
            yOffset += fSize * 1.2; 
        } else { line = test; }
    }
    ctx.fillText(line, 0, yOffset);
    ctx.restore();
    ctx.restore();
}

playBtn.onclick = () => {
    isPlaying = !isPlaying;
    playBtn.textContent = isPlaying ? "pause_circle_filled" : "play_circle_filled";
    if (userAudio) { userAudio.currentTime = currentTime; isPlaying ? userAudio.play() : userAudio.pause(); }
    if (isPlaying) { lastFrameTime = performance.now(); requestAnimationFrame(playLoop); }
};

function playLoop(now) {
    if (!isPlaying) return;
    currentTime += (now - lastFrameTime) / 1000;
    lastFrameTime = now;
    if (currentTime >= totalSecs) { currentTime = 0; isPlaying = false; if(userAudio) userAudio.pause(); }
    timeline.value = currentTime;
    updateFrame();
    requestAnimationFrame(playLoop);
}

// THE DURATIONAL EXPORT ENGINE (FIXES DOWNLOAD AND DURATION)
async function exportHQVideo() {
    isPlaying = false;
    renderOverlay.style.display = "flex";
    
    const stream = canvas.captureStream(0); 
    const recorder = new MediaRecorder(stream, { 
        mimeType: "video/webm;codecs=vp9", 
        videoBitsPerSecond: 25000000 
    });
    
    const chunks = [];
    recorder.ondataavailable = e => chunks.push(e.data);
    
    recorder.onstop = () => {
        const blob = new Blob(chunks, {type: "video/webm"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `VoidUpLift_${Date.now()}.webm`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        renderOverlay.style.display = "none";
        statusMsg.textContent = "Saved to Downloads!";
    };

    recorder.start();

    // Deterministic loop for perfect duration
    const fps = 30;
    const totalFrames = totalSecs * fps;
    for (let i = 0; i <= totalFrames; i++) {
        currentTime = i / fps; 
        drawCanvas(currentTime);
        stream.getVideoTracks()[0].requestFrame(); 
        
        let progress = Math.round((i / totalFrames) * 100);
        renderProgress.textContent = `RENDERING ${progress}%`;
        
        await new Promise(r => setTimeout(r, 10)); 
    }

    recorder.stop();
}

window.onload = () => setTimeout(updateFrame, 500);
</script>
</body>
</html>
