<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VoidUpLift Reels Editor Pro</title>

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&family=Anton&family=Bebas+Neue&family=Playfair+Display&family=Oswald&family=Pacifico&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <style>
        /* ---------- RESET & CORE ---------- */
        *{ box-sizing:border-box; margin:0; padding:0; }
        body{ background:#000; color:#fff; font-family:'Poppins', sans-serif; height:100vh; overflow:hidden; }
        .app{ display:flex; flex-direction:column; height:100vh; max-width: 500px; margin: 0 auto; border: 1px solid #222; position: relative; }

        /* ---------- PREVIEW AREA ---------- */
        .preview{ 
            display:flex; 
            flex-direction:column; 
            align-items:center; 
            padding:10px; 
            background:#111; 
            flex-shrink: 0;
        }
        canvas{ 
            width:auto; 
            height:38vh; 
            aspect-ratio:9/16; 
            border-radius:12px; 
            border:2px solid #333; 
            background:#000; 
            cursor: crosshair; 
            touch-action: none; 
        }
        .play-btn-ui{ font-size:42px; margin-top:8px; cursor:pointer; color: #00f2ea; }
        #timeline { width: 90%; margin: 10px 0; accent-color: #00f2ea; cursor: pointer; height: 14px; }

        /* ---------- ICON NAVIGATION ---------- */
        .iconbar{ 
            display:flex; 
            justify-content:space-around; 
            padding:12px 0; 
            background:#080808; 
            border-top:1px solid #222;
        }
        .iconbar span{ font-size:28px; cursor:pointer; color: #666; transition: 0.3s; }
        .iconbar span.active-tab { color: #00f2ea; }

        /* ---------- CONTROLS AREA ---------- */
        .controls{ 
            flex:1; 
            background:#080808; 
            overflow-y:auto; 
            padding:15px; 
        }
        .panel{ display:none; animation: fadeIn 0.2s ease; }
        .panel.active{ display:block; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        label { display: block; margin-bottom: 6px; font-size: 11px; color: #00f2ea; text-transform: uppercase; font-weight: bold; letter-spacing: 1px; }
        textarea, input[type="text"], input[type="number"], select { 
            width:100%; 
            background:#151515; 
            border:1px solid #333; 
            color:#fff; 
            padding:12px; 
            margin-bottom:15px; 
            border-radius: 8px; 
            font-size: 14px;
            outline: none; 
        }
        input[type="range"] { width: 100%; margin-bottom: 20px; accent-color: #00f2ea; }

        .status-bar{ text-align:center; font-size:12px; color:#00f2ea; padding:10px; background: #050505; font-weight: bold; }
        
        /* Loading Overlay */
        #loadingOverlay {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>

<body>
<div class="app">
    <div id="loadingOverlay">
        <div class="status-bar" id="progressText">Rendering 0%</div>
        <p style="font-size: 10px; color: #666;">Don't close the app</p>
    </div>

    <div class="preview">
        <canvas id="canvas" width="1080" height="1920"></canvas>
        <div style="display:flex; align-items:center; width:100%; justify-content:center; gap:15px;">
            <span id="playBtn" class="material-icons play-btn-ui">play_circle_filled</span>
            <input type="range" id="timeline" min="0" max="5" step="0.01" value="0">
        </div>
    </div>

    <div class="iconbar">
        <span class="material-icons active-tab" onclick="showPanel('textP', this)">text_fields</span>
        <span class="material-icons" onclick="showPanel('imgP', this)">image</span>
        <span id="exportBtn" class="material-icons" style="color:#00f2ea">download</span>
    </div>

    <div class="controls">
        <div id="textP" class="panel active">
            <label>Content</label>
            <textarea id="textInput" rows="2">VoidUpLift</textarea>
            
            <label>Text Size</label>
            <input type="range" id="fontSizeRange" min="40" max="300" value="120">
            
            <label>Font Style</label>
            <select id="fontFamilySelect">
                <option value="Poppins">Poppins</option>
                <option value="Anton">Anton</option>
                <option value="Bebas Neue">Bebas Neue</option>
                <option value="Pacifico">Pacifico</option>
                <option value="Oswald">Oswald</option>
            </select>
        </div>

        <div id="imgP" class="panel">
            <label>Picture (Fits Layout)</label>
            <input type="file" id="bgUpload" accept="image/*">
            
            <label>Video Length (Sec)</label>
            <input type="number" id="videoDuration" value="5">
        </div>
    </div>

    <div class="status-bar" id="statusMsg">Ready to Edit</div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const timeline = document.getElementById("timeline");
const exportBtn = document.getElementById("exportBtn");
const statusMsg = document.getElementById("statusMsg");
const loadingOverlay = document.getElementById("loadingOverlay");
const progressText = document.getElementById("progressText");

let bgImg = new Image();
let textStr = "VoidUpLift", currentFont = "Poppins", fSize = 120;
let totalSecs = 5, currentTime = 0, isPlaying = false, lastFrameTime = 0;

function showPanel(id, iconEl) {
    document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
    document.querySelectorAll('.iconbar span').forEach(s => s.classList.remove('active-tab'));
    document.getElementById(id).classList.add('active');
    iconEl.classList.add('active-tab');
}

function updateFrame() { drawCanvas(currentTime); }

// UI Sync
textInput.oninput = e => { textStr = e.target.value; updateFrame(); };
fontSizeRange.oninput = e => { fSize = parseInt(e.target.value); updateFrame(); };
fontFamilySelect.onchange = e => { currentFont = e.target.value; updateFrame(); };
videoDuration.oninput = e => { totalSecs = +e.target.value; timeline.max = totalSecs; updateFrame(); };
timeline.oninput = e => { currentTime = parseFloat(e.target.value); updateFrame(); };

bgUpload.onchange = e => { 
    if(e.target.files[0]) { 
        bgImg.src = URL.createObjectURL(e.target.files[0]); 
        bgImg.onload = updateFrame; 
    } 
};

function drawCanvas(t) {
    // 1. Clear background
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, 1080, 1920);

    // 2. Exact Fit Image (No stretching, centered)
    if(bgImg.complete && bgImg.width) {
        let canvasW = 1080;
        let canvasH = 1920;
        let ratio = Math.min(canvasW / bgImg.width, canvasH / bgImg.height);
        
        let newWidth = bgImg.width * ratio;
        let newHeight = bgImg.height * ratio;
        let x = (canvasW - newWidth) / 2;
        let y = (canvasH - newHeight) / 2;
        
        ctx.drawImage(bgImg, x, y, newWidth, newHeight);
    }

    // 3. Text Overlay
    ctx.fillStyle = "white";
    ctx.font = `bold ${fSize}px "${currentFont}"`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    // Simple Shadow for readability
    ctx.shadowColor = "rgba(0,0,0,0.5)";
    ctx.shadowBlur = 15;
    
    ctx.fillText(textStr, 540, 960);
    ctx.shadowBlur = 0; // reset shadow
}

playBtn.onclick = () => {
    isPlaying = !isPlaying;
    playBtn.textContent = isPlaying ? "pause_circle_filled" : "play_circle_filled";
    if (isPlaying) { 
        lastFrameTime = performance.now(); 
        requestAnimationFrame(playLoop); 
    }
};

function playLoop(now) {
    if (!isPlaying) return;
    currentTime += (now - lastFrameTime) / 1000;
    lastFrameTime = now;
    
    if (currentTime >= totalSecs) { 
        currentTime = 0; 
        isPlaying = false; 
        playBtn.textContent = "play_circle_filled"; 
    }
    
    timeline.value = currentTime;
    updateFrame();
    requestAnimationFrame(playLoop);
}

// HIGH-COMPATIBILITY EXPORT ENGINE
exportBtn.onclick = async () => {
    if(isPlaying) isPlaying = false;
    
    loadingOverlay.style.display = 'flex';
    statusMsg.textContent = "Initializing Export...";
    
    const chunks = [];
    // Using 30fps for smooth motion
    const stream = canvas.captureStream(30);
    
    // Check for supported mime types
    const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') 
                     ? 'video/webm;codecs=vp9' 
                     : 'video/webm';
                     
    const recorder = new MediaRecorder(stream, { 
        mimeType: mimeType,
        videoBitsPerSecond: 5000000 // 5Mbps for high quality
    });

    recorder.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };
    
    recorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `VoidUpLift_${Date.now()}.webm`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        loadingOverlay.style.display = 'none';
        statusMsg.textContent = "Saved to Downloads!";
    };

    recorder.start();
    
    // Manual Render Process (Frames stepping)
    const fps = 30;
    const totalFrames = totalSecs * fps;
    
    for(let i = 0; i <= totalFrames; i++) {
        currentTime = i / fps;
        updateFrame();
        
        // Progress UI
        let percent = Math.round((i / totalFrames) * 100);
        progressText.innerText = `Rendering ${percent}%`;
        
        // Force stream to capture the current frame
        stream.getVideoTracks()[0].requestFrame();
        
        // Small delay to allow the browser to process the frame
        await new Promise(r => setTimeout(r, 16)); 
    }
    
    recorder.stop();
};

window.onload = () => {
    setTimeout(updateFrame, 500);
};
</script>
</body>
</html>
