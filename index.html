<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dark MP3 Player — Siva Manihandan</title>
<meta name="description" content="Dark local MP3 player — artist Siva Manihandan">
<style>
  /* Modern dark UI, compact and professional */
  :root{
    --bg-0:#041018;
    --bg-1:#071019;
    --panel:#0f1519;
    --muted:#98a4ad;
    --accent:#1db954;
    --glass: rgba(255,255,255,0.03);
    --card: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    --text:#e8f0f4;
    --radius:14px;
    --shadow: 0 8px 30px rgba(2,6,10,0.6);
    --gap:18px;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-0),var(--bg-1));color:var(--text);-webkit-font-smoothing:antialiased}
  .app{display:grid;grid-template-columns:320px 1fr;gap:var(--gap);height:100vh;padding:24px}
  .card{
    background:var(--card);border-radius:var(--radius);padding:18px;box-shadow:var(--shadow);display:flex;flex-direction:column;min-height:0;
    border:1px solid rgba(255,255,255,0.02);
  }
  .cover{
    border-radius:12px;overflow:hidden;height:320px;background:linear-gradient(180deg,#0b0f12,#071018);display:flex;align-items:center;justify-content:center;
    transition:transform .28s cubic-bezier(.2,.9,.3,1);
  }
  .cover img{width:100%;height:100%;object-fit:cover;display:block}
  .meta{margin-top:14px}
  .title{font-weight:700;font-size:18px;letter-spacing:0.2px}
  .artist{color:var(--muted);font-size:13px;margin-top:6px}
  .controls{display:flex;align-items:center;gap:10px;margin-top:14px}
  .btn{background:transparent;border:none;padding:10px;border-radius:10px;color:var(--text);cursor:pointer;backdrop-filter: blur(4px);font-size:18px}
  .btn:hover{background:rgba(255,255,255,0.02)}
  .play{width:62px;height:62px;border-radius:12px;background:linear-gradient(180deg,var(--accent),#16a84a);color:#01120a;font-weight:700;font-size:20px;display:inline-flex;align-items:center;justify-content:center;box-shadow:0 6px 22px rgba(29,185,84,0.16);border:none;cursor:pointer}
  .seek-wrap{margin-top:14px}
  input[type=range]{width:100%;-webkit-appearance:none;height:6px;border-radius:6px;background:rgba(255,255,255,0.04);outline:none}
  input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:var(--accent);box-shadow:0 2px 6px rgba(0,0,0,0.4);cursor:pointer}
  .time-row{display:flex;justify-content:space-between;font-size:12px;color:var(--muted);margin-top:8px}
  .settings{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap}
  .chip{background:#0b1316;padding:8px 12px;border-radius:999px;font-size:13px;color:var(--muted);display:inline-flex;align-items:center;gap:8px}
  .panel{background:transparent;border-radius:var(--radius);padding:10px;display:flex;flex-direction:column;min-height:0}
  .toolbar{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;gap:8px}
  .search{flex:1;background:#071018;border-radius:10px;padding:10px 12px;display:flex;gap:10px;align-items:center;border:1px solid rgba(255,255,255,0.02)}
  .search input{background:transparent;border:0;outline:0;color:var(--text);width:100%}
  .icons{display:flex;gap:8px;align-items:center}
  .playlist{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:12px;padding:10px;overflow:auto;flex:1;box-shadow:inset 0 -30px 60px rgba(0,0,0,0.25)}
  .track{display:grid;grid-template-columns:52px 1fr 90px;gap:12px;align-items:center;padding:8px;border-radius:10px;cursor:pointer;transition:background .12s}
  .track:hover{background:rgba(255,255,255,0.02)}
  .track.active{background:linear-gradient(90deg, rgba(29,185,84,0.08), rgba(29,185,84,0.03));}
  .track .thumb{width:52px;height:52px;border-radius:8px;overflow:hidden;flex-shrink:0}
  .track .name{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .track .sub{font-size:12px;color:var(--muted)}
  .track .time{font-size:12px;color:var(--muted);text-align:right}
  .mini{position:fixed;left:20px;right:20px;bottom:20px;height:72px;background:#071017;border-radius:12px;padding:10px;display:flex;align-items:center;gap:12px;box-shadow:0 18px 50px rgba(2,6,10,0.6);cursor:pointer}
  .mini .thumb{width:56px;height:56px;border-radius:8px;overflow:hidden}
  .mini .info{flex:1;min-width:0}
  .mini .title{font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .mini .artist{font-size:12px;color:var(--muted)}
  .mini .controls{display:flex;gap:8px;align-items:center}
  @media (max-width:920px){
    .app{grid-template-columns:1fr;gap:12px;padding:12px}
    .cover{height:220px}
    .card{order:2}
    .panel{order:1}
  }
  /* small helper */
  .muted-small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
  <div class="app" id="app">
    <div class="card">
      <div class="cover" id="cover"><img id="coverImg" alt="cover"></div>

      <div class="meta">
        <div class="title" id="trackTitle">No track loaded</div>
        <div class="artist" id="artistLabel">Siva Manihandan</div>
      </div>

      <div class="controls">
        <button class="btn" id="prevBtn" title="Previous">⏮</button>
        <button class="play" id="playBtn" title="Play/Pause">▶</button>
        <button class="btn" id="nextBtn" title="Next">⏭</button>
        <div style="flex:1"></div>
        <div class="chip" id="count">0 tracks</div>
      </div>

      <div class="seek-wrap">
        <input type="range" id="seek" min="0" max="100" value="0" />
        <div class="time-row"><span id="curTime">0:00</span><span id="durTime">0:00</span></div>
      </div>

      <div class="settings">
        <div class="chip">Volume <input id="vol" type="range" min="0" max="1" step="0.01" value="0.9" style="margin-left:8px;vertical-align:middle"></div>
        <div class="chip"><label style="cursor:pointer"><input id="shuffle" type="checkbox" style="margin-right:8px">Shuffle</label></div>
        <div class="chip"><label style="cursor:pointer"><input id="repeat" type="checkbox" style="margin-right:8px">Repeat</label></div>
        <div style="flex:1"></div>
        <div class="chip" id="autoplayChip" title="Toggle autoplay">Autoplay: On</div>
      </div>
    </div>

    <div class="panel">
      <div class="toolbar">
        <div class="search" title="Filter tracks"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="opacity:.9"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg><input id="filter" placeholder="Filter tracks..." /></div>
        <div class="icons">
          <button class="btn" id="import" title="Import (drag & drop)">⤓</button>
        </div>
      </div>

      <div class="playlist" id="playlist" role="list"></div>
      <div class="muted-small" style="margin-top:8px">Tip: Drag & drop audio files or click the import button. For server-hosted files provide <code>list.json</code> or a directory listing.</div>
    </div>
  </div>

  <div class="mini" id="mini" title="Open player">
    <div class="thumb" id="miniThumb"><img id="miniImg" style="width:100%;height:100%;object-fit:cover"></div>
    <div class="info">
      <div class="title" id="miniTitle">No track</div>
      <div class="artist" id="miniArtist">Siva Manihandan</div>
    </div>
    <div class="controls">
      <button class="btn" id="miniPrev" title="Previous">⏮</button>
      <button class="play" id="miniPlay" title="Play/Pause">▶</button>
      <button class="btn" id="miniNext" title="Next">⏭</button>
    </div>
  </div>

  <audio id="player" preload="metadata"></audio>

<script>
/* Improved player:
   - Durations collected for both local blobs and server URLs (via an offscreen Audio element).
   - Robust auto-detect: list.json first, then directory listing parse.
   - Keeps UI minimal & professional.
*/

const DEFAULT_ARTIST = 'Siva Manihandan';
const AUDIO_RE = /\.(mp3|m4a|wav|ogg|flac)(\?.*)?$/i;

const player = document.getElementById('player');
const playlistEl = document.getElementById('playlist');
const playBtn = document.getElementById('playBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const seek = document.getElementById('seek');
const curTime = document.getElementById('curTime');
const durTime = document.getElementById('durTime');
const countEl = document.getElementById('count');
const vol = document.getElementById('vol');
const shuffleEl = document.getElementById('shuffle');
const repeatEl = document.getElementById('repeat');
const autoplayChip = document.getElementById('autoplayChip');
const filterInput = document.getElementById('filter');
const coverImg = document.getElementById('coverImg');

const mini = document.getElementById('mini');
const miniImg = document.getElementById('miniImg');
const miniTitle = document.getElementById('miniTitle');
const miniArtist = document.getElementById('miniArtist');
const miniPlay = document.getElementById('miniPlay');
const miniPrev = document.getElementById('miniPrev');
const miniNext = document.getElementById('miniNext');

let tracks = []; // {name, url, artist, source, thumb, duration, _blob}
let current = 0;
let isShuffle = false;
let isRepeat = false;
let autoplay = true;

vol.addEventListener('input', ()=> { player.volume = vol.value; });
player.volume = vol.value;
shuffleEl.addEventListener('change', ()=> { isShuffle = shuffleEl.checked; });
repeatEl.addEventListener('change', ()=> { isRepeat = repeatEl.checked; });

// time formatting (digit-by-digit safe)
function fmtTime(s){
  if(isNaN(s) || !isFinite(s)) return '0:00';
  const m = Math.floor(s/60);
  const sec = Math.floor(s%60).toString().padStart(2,'0');
  return `${m}:${sec}`;
}

// deterministic color generator from string
function hashString(s){
  let h=2166136261 >>> 0;
  for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h += (h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24); h = h >>> 0; }
  return h >>> 0;
}
function pickColors(seed){
  const h = hashString(seed);
  const a = (h & 0xFFFFFF).toString(16).padStart(6,'0');
  const b = ((h >> 8) & 0xFFFFFF).toString(16).padStart(6,'0');
  const c = ((h >> 16) & 0xFFFFFF).toString(16).padStart(6,'0');
  return ['#'+a,'#'+b,'#'+c];
}

// generate SVG thumbnail data URL using gradients and initials
function makeThumb(title){
  const colors = pickColors(title);
  const initials = title.split(/[\s\-_]+/).map(t=>t[0]||'').slice(0,2).join('').toUpperCase() || 'S';
  const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='512' height='512'>
    <defs>
      <linearGradient id='g' x1='0' x2='1' y1='0' y2='1'>
        <stop offset='0' stop-color='${colors[0]}'/>
        <stop offset='0.6' stop-color='${colors[1]}'/>
        <stop offset='1' stop-color='${colors[2]}'/>
      </linearGradient>
    </defs>
    <rect width='100%' height='100%' fill='url(#g)'/>
    <g fill='rgba(255,255,255,0.12)'><circle cx='420' cy='100' r='60'/><circle cx='80' cy='420' r='50'/></g>
    <text x='50%' y='54%' font-size='140' text-anchor='middle' fill='rgba(255,255,255,0.92)' font-family='Inter,Arial,Helvetica' font-weight='700'>${escapeHtml(initials)}</text>
  </svg>`;
  return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}
function escapeHtml(s){ return String(s).replace(/[&<>"'`]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','`':'&#96;'}[c])); }

// Render playlist (filter applied)
function render(filter=''){
  playlistEl.innerHTML = '';
  const filtered = tracks.filter(t => (t.name + ' ' + (t.artist||'')).toLowerCase().includes(filter.toLowerCase()));
  filtered.forEach((t) => {
    const i = tracks.indexOf(t);
    const row = document.createElement('div');
    row.className = 'track' + (i === current ? ' active' : '');
    row.dataset.index = i;
    row.innerHTML = `
      <div class="thumb"><img src="${t.thumb}" alt="" style="width:100%;height:100%;object-fit:cover;border-radius:8px"></div>
      <div style="min-width:0">
        <div class="name">${escapeHtml(t.name)}</div>
        <div class="sub">${escapeHtml(t.artist || DEFAULT_ARTIST)}</div>
      </div>
      <div class="time">${t.duration ? fmtTime(t.duration) : ''}</div>
    `;
    row.addEventListener('click', ()=> playIndex(i));
    playlistEl.appendChild(row);
  });
  countEl.textContent = tracks.length + ' tracks';
  updateMini();
}

// update mini player
function updateMini(){
  const t = tracks[current];
  miniTitle.textContent = t ? t.name : 'No track';
  miniArtist.textContent = t ? (t.artist || DEFAULT_ARTIST) : DEFAULT_ARTIST;
  miniImg.src = t ? t.thumb : '';
  const paused = player.paused || !player.src;
  miniPlay.textContent = paused ? '▶' : '⏸';
  playBtn.textContent = paused ? '▶' : '⏸';
}

// set page metadata & media notification
function setMeta(t){
  document.getElementById('trackTitle').textContent = t ? t.name : 'No track';
  document.getElementById('artistLabel').textContent = t ? (t.artist || DEFAULT_ARTIST) : DEFAULT_ARTIST;
  coverImg.src = t ? t.thumb : '';
  if('mediaSession' in navigator && t){
    try{
      navigator.mediaSession.metadata = new MediaMetadata({
        title: t.name,
        artist: t.artist || DEFAULT_ARTIST,
        album: 'Local',
        artwork: [{ src: t.thumb, sizes: '512x512', type: 'image/png' }]
      });
    }catch(e){}
  }
}

// ensure a track index exists
function playIndex(i){
  if(tracks.length === 0) return;
  if(i<0) i = 0;
  if(i>=tracks.length) i = 0;
  current = i;
  const t = tracks[current];
  if(!t) return;
  // set src and try play
  player.src = t.url;
  setMeta(t);
  player.play().then(()=> {
    // playing
  }).catch(()=> {
    // may require user gesture — UI stays consistent
  });
  updateMini();
  render(filterInput.value);
}

// next / prev logic
function playNext(){
  if(isRepeat){
    player.currentTime = 0; player.play(); return;
  }
  if(isShuffle){
    if(tracks.length===0) return;
    const n = Math.floor(Math.random()*tracks.length);
    playIndex(n); return;
  }
  if(current < tracks.length - 1) playIndex(current+1);
  else playIndex(0);
}
function playPrev(){
  if(player.currentTime > 3){ player.currentTime = 0; player.play(); return; }
  if(current > 0) playIndex(current-1); else playIndex(0);
}

// update seek during playback
player.addEventListener('timeupdate', ()=> {
  if(player.duration){
    seek.value = (player.currentTime / player.duration) * 100;
    curTime.textContent = fmtTime(player.currentTime);
    durTime.textContent = fmtTime(player.duration);
  }
});
player.addEventListener('ended', ()=> { if(autoplay) playNext(); else { playBtn.textContent = '▶'; miniPlay.textContent = '▶'; } });

// update duration when metadata available (for server urls)
player.addEventListener('loadedmetadata', ()=> {
  if(player.duration && tracks[current]) {
    tracks[current].duration = player.duration;
    durTime.textContent = fmtTime(player.duration);
    render(filterInput.value);
  }
});

seek.addEventListener('input', ()=> {
  if(player.duration) player.currentTime = (seek.value / 100) * player.duration;
});

// play/pause handlers
playBtn.addEventListener('click', ()=>{
  if(!player.src && tracks.length) { playIndex(0); return; }
  if(player.paused){ player.play(); playBtn.textContent='⏸'; miniPlay.textContent='⏸'; }
  else { player.pause(); playBtn.textContent='▶'; miniPlay.textContent='▶'; }
});
prevBtn.addEventListener('click', playPrev);
nextBtn.addEventListener('click', ()=> playNext());

miniPrev.addEventListener('click', e=>{ e.stopPropagation(); playPrev(); });
miniNext.addEventListener('click', e=>{ e.stopPropagation(); playNext(); });
miniPlay.addEventListener('click', e=>{ e.stopPropagation(); playBtn.click(); });

// keyboard shortcuts (prevent when typing)
window.addEventListener('keydown', e=> {
  const tag = document.activeElement && document.activeElement.tagName.toLowerCase();
  if(tag === 'input' || tag === 'textarea') return;
  if(e.code==='Space'){ e.preventDefault(); playBtn.click(); }
  if(e.code==='ArrowRight') nextBtn.click();
  if(e.code==='ArrowLeft') prevBtn.click();
});

// media session controls
if('mediaSession' in navigator){
  try{
    navigator.mediaSession.setActionHandler('play', ()=>{ player.play(); playBtn.textContent='⏸'; miniPlay.textContent='⏸'; });
    navigator.mediaSession.setActionHandler('pause', ()=>{ player.pause(); playBtn.textContent='▶'; miniPlay.textContent='▶'; });
    navigator.mediaSession.setActionHandler('previoustrack', ()=> playPrev());
    navigator.mediaSession.setActionHandler('nexttrack', ()=> playNext());
  }catch(e){}
}

// drag & drop / file import
function handleFiles(list){
  const files = Array.from(list).filter(f => AUDIO_RE.test(f.name));
  if(files.length === 0) return;
  files.sort((a,b)=> a.name.localeCompare(b.name, undefined, {numeric:true, sensitivity:'base'}));
  // revoke old blob urls
  tracks.forEach(t=> { if(t._blob) URL.revokeObjectURL(t.url); });
  tracks = files.map(f => {
    const name = f.name.replace(/\.[^/.]+$/,'');
    return { name, url: URL.createObjectURL(f), artist: DEFAULT_ARTIST, source:'local', _blob:true, thumb: makeThumb(name) };
  });
  // fetch durations for blobs by loading metadata on temp audio elements
  populateDurationsForAll(tracks).then(()=> {
    render('');
    if(tracks.length) playIndex(0);
  });
}
document.body.addEventListener('dragover', e=> { e.preventDefault(); });
document.body.addEventListener('drop', e=> { e.preventDefault(); if(e.dataTransfer && e.dataTransfer.files) handleFiles(e.dataTransfer.files); });

// import button create file input
document.getElementById('import').addEventListener('click', ()=> {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.multiple = true;
  inp.accept = '.mp3,.m4a,.wav,.ogg,.flac';
  inp.onchange = ()=> { if(inp.files) handleFiles(inp.files); };
  inp.click();
});

// helper: load duration for a single track (works for blobs and remote URLs)
function loadDurationForTrack(track){
  return new Promise((resolve)=> {
    if(track.duration && !isNaN(track.duration)) return resolve(track);
    const a = document.createElement('audio');
    a.preload = 'metadata';
    a.src = track.url;
    const tidy = ()=> { try{ a.remove(); }catch(e){} };
    const onloaded = ()=> {
      if(!isNaN(a.duration) && isFinite(a.duration)) track.duration = a.duration;
      tidy();
      resolve(track);
    };
    const onerror = ()=> { tidy(); resolve(track); };
    a.addEventListener('loadedmetadata', onloaded, {once:true});
    a.addEventListener('error', onerror, {once:true});
    // start load
    a.load();
    // safety: timeout after 6s
    setTimeout(()=> { resolve(track); try{ a.remove(); }catch(e){} }, 6000);
  });
}
async function populateDurationsForAll(list){
  const promises = list.map(t => loadDurationForTrack(t));
  await Promise.all(promises);
}

// server autodetect (tries list.json then directory listing)
async function tryAutoLoad(){
  // try list.json first
  try {
    const r = await fetch('./list.json', {cache:'no-store'});
    if(r.ok){
      const arr = await r.json();
      if(Array.isArray(arr) && arr.length){
        const list = arr.filter(n => AUDIO_RE.test(n)).map(n => {
          const name = decodeURIComponent(n.split('/').pop()).replace(/\.[^/.]+$/,'');
          return { name, url: n, artist: DEFAULT_ARTIST, source:'listjson', thumb: makeThumb(name) };
        });
        tracks = list;
        await populateDurationsForAll(tracks);
        render(''); if(tracks.length) playIndex(0);
        return;
      }
    }
  }catch(e){ /* ignore network errors */ }

  // try fetch directory root and parse anchor tags (works on some static servers)
  try {
    const r = await fetch('./', {cache:'no-store'});
    if(r.ok){
      const text = await r
