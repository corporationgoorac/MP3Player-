<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MP3 Player — Debug Loader</title>
<meta name="description" content="Diagnostic page to debug GitHub MP3 auto-loader" />
<style>
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:18px;background:#071018;color:#e8f0f4}
  h1{font-size:18px;margin:0 0 8px}
  .box{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border:1px solid rgba(255,255,255,0.03);padding:14px;border-radius:10px;margin-bottom:12px}
  pre{white-space:pre-wrap;font-size:13px;color:#dbeef1;overflow:auto;max-height:280px}
  .ok{color:#8ee08e}
  .bad{color:#ff9b9b}
  .muted{color:#98a4ad}
  button{background:#0f2b20;border:1px solid rgba(255,255,255,0.02);color:#dff6e6;padding:8px 10px;border-radius:8px;cursor:pointer}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  td,th{padding:8px;border-bottom:1px solid rgba(255,255,255,0.02);font-size:13px}
  th{color:#9fb0b6;text-align:left}
  .small{font-size:13px;color:#9fb0b6}
</style>
</head>
<body>
  <h1>MP3 Loader — Diagnostic</h1>
  <div class="box">
    <div class="small">Repo checked: <b>corporationgoorac/MP3Player- (branch: main)</b></div>
    <div style="margin-top:8px">
      <button id="runBtn">Run loader diagnostics</button>
      <button id="copyLog" style="margin-left:8px">Copy diagnostics</button>
    </div>
  </div>

  <div id="logArea" class="box">
    <strong>Step log</strong>
    <pre id="log">Press "Run loader diagnostics".</pre>
  </div>

  <div id="resultArea" class="box" style="display:none">
    <strong>Detected files</strong>
    <div id="summary" class="small" style="margin-top:6px"></div>
    <table id="filesTable" style="margin-top:8px">
      <thead><tr><th>#</th><th>Filename</th><th>Raw URL</th><th>Status</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

<script>
(async function(){
  const OWNER = 'corporationgoorac';
  const REPO = 'MP3Player-';
  const BRANCH = 'main';
  const AUDIO_RE = /\.mp3(\?.*)?$/i;

  const runBtn = document.getElementById('runBtn');
  const logEl = document.getElementById('log');
  const resultArea = document.getElementById('resultArea');
  const filesTbody = document.querySelector('#filesTable tbody');
  const summary = document.getElementById('summary');
  const copyBtn = document.getElementById('copyLog');

  function log(s){ logEl.textContent += '\\n' + s; logEl.scrollTop = logEl.scrollHeight; }
  function reset(){ logEl.textContent = ''; resultArea.style.display='none'; filesTbody.innerHTML=''; summary.textContent=''; }

  // small timeout fetch helper
  async function fetchWithTimeout(url, opts = {}, ms = 7000){
    const ac = new AbortController();
    const id = setTimeout(()=> ac.abort(), ms);
    try{
      const r = await fetch(url, {...opts, signal: ac.signal});
      clearTimeout(id);
      return r;
    }catch(e){
      clearTimeout(id);
      throw e;
    }
  }

  // try GitHub REST API
  async function tryApi(){
    log('→ Trying GitHub contents API...');
    const api = `https://api.github.com/repos/${OWNER}/${REPO}/contents/?ref=${BRANCH}`;
    try{
      const res = await fetchWithTimeout(api, { headers: { 'Accept': 'application/vnd.github.v3+json' } }, 8000);
      log(`  API response status: ${res.status} ${res.statusText}`);
      if(!res.ok){
        const text = await res.text().catch(()=> '');
        log('  API returned non-OK. Response snippet:\\n' + (text.slice(0,600) || '[empty]'));
        return { ok:false, reason:'api-status-'+res.status };
      }
      const json = await res.json();
      if(!Array.isArray(json)){ log('  API did not return an array.'); return { ok:false, reason:'api-badjson' }; }
      const mp3 = json.filter(i => i.type === 'file' && AUDIO_RE.test(i.name));
      log('  API found ' + mp3.length + ' mp3 file(s).');
      return { ok: true, list: mp3.map(x=>({name: x.name, download_url: x.download_url, size: x.size})) };
    }catch(err){
      log('  API fetch failed: ' + (err && err.message ? err.message : String(err)));
      return { ok:false, reason:'api-exception', error: String(err) };
    }
  }

  // fallback: parse GitHub tree HTML for /blob/.../*.mp3 links
  async function tryParsePage(){
    log('→ Trying HTML parse fallback (repo page) ...');
    const pageUrl = `https://github.com/${OWNER}/${REPO}/tree/${BRANCH}`;
    try{
      const res = await fetchWithTimeout(pageUrl, {}, 9000);
      log('  Page response: ' + res.status + ' ' + res.statusText);
      if(!res.ok){
        const t = await res.text().catch(()=>'');
        log('  Page fetch non-OK. Snippet:\\n' + (t.slice(0,500) || '[empty]'));
        return { ok:false, reason:'page-status-'+res.status };
      }
      const text = await res.text();
      // find blob links like /owner/repo/blob/main/Some%20File.mp3
      const blobRegex = /href="(\/[^"]+\/blob\/[^"]+\.mp3(?:\?[^"]*)?)"/ig;
      const matches = Array.from(text.matchAll(blobRegex));
      log('  Found ' + matches.length + ' blob link match(es) in page HTML.');
      const filenames = [];
      for(const m of matches){
        const href = m[1];
        const parts = href.split('/');
        const encodedName = parts[parts.length - 1];
        try{
          const name = decodeURIComponent(encodedName);
          if(AUDIO_RE.test(name) && !filenames.includes(name)) filenames.push(name);
        }catch(e){}
      }
      log('  Parsed ' + filenames.length + ' unique filename(s).');
      const list = filenames.map(fn => {
        const raw = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/${encodeURIComponent(fn)}`;
        return { name: fn, raw };
      });
      return { ok:true, list };
    }catch(err){
      log('  Page parse failed: ' + (err && err.message ? err.message : String(err)));
      return { ok:false, reason:'page-exception', error: String(err) };
    }
  }

  // check a raw URL reachability & CORS by trying a HEAD then small GET (range)
  async function checkUrl(url){
    log('    Checking: ' + url);
    // try HEAD
    try{
      const h = await fetchWithTimeout(url, { method:'HEAD' }, 7000);
      log('      HEAD status: ' + h.status + ' ' + h.statusText);
      if(h.ok){
        const ct = h.headers.get('content-type') || '';
        return { ok:true, status:h.status, contentType:ct };
      }
    }catch(e){
      log('      HEAD failed: ' + (e && e.message ? e.message : String(e)));
    }
    // try short GET with range header (may return 206 or 200)
    try{
      const g = await fetchWithTimeout(url, { method:'GET', headers:{ Range:'bytes=0-1023' } }, 9000);
      log('      GET status: ' + g.status + ' ' + g.statusText);
      if(g.ok || g.status === 206){
        const ct = g.headers.get('content-type') || '';
        const len = g.headers.get('content-length') || '[unknown]';
        log('      content-type: ' + ct + ', content-length: ' + len);
        return { ok:true, status:g.status, contentType:ct, length: len };
      } else {
        return { ok:false, status:g.status, reason:'get-not-ok' };
      }
    }catch(e){
      log('      GET failed: ' + (e && e.message ? e.message : String(e)));
      return { ok:false, error: String(e) };
    }
  }

  async function run(){
    reset();
    log('=== Loader diagnostics started at ' + new Date().toLocaleString() + ' ===');
    log('1) Trying GitHub API...');
    const apiResult = await tryApi();
    if(apiResult.ok){
      log('> API succeeded, found ' + apiResult.list.length + ' mp3(s).');
      const files = apiResult.list.map((it) => ({ name: it.name, url: it.download_url }));
      // test reachability
      filesTbody.innerHTML = '';
      for(let i=0;i<files.length;i++){
        const f = files[i];
        const row = document.createElement('tr');
        row.innerHTML = `<td>${i+1}</td><td>${f.name}</td><td style="word-break:break-all">${f.url}</td><td>checking..</td>`;
        filesTbody.appendChild(row);
      }
      // perform checks
      for(let i=0;i<files.length;i++){
        const f = files[i];
        const res = await checkUrl(f.url);
        const tr = filesTbody.children[i];
        tr.children[3].textContent = res.ok ? ('OK ' + (res.status || '')) : ('ERROR: ' + (res.status || res.reason || res.error || 'unknown'));
      }
      summary.textContent = 'Loaded from API: ' + files.length + ' file(s).';
      resultArea.style.display = '';
      log('Done API path.');
      return;
    } else {
      log('> API failed or returned no files. Reason: ' + (apiResult.reason || apiResult.error || 'unknown'));
    }

    log('2) Trying HTML page parse fallback...');
    const parseResult = await tryParsePage();
    if(!parseResult.ok){
      log('> Page parse failed. Reason: ' + (parseResult.reason || parseResult.error || 'unknown'));
      log('\\n====== DIAGNOSTIC SUMMARY ======');
      log('Auto-loader could not detect MP3 files via API or page parse. Common causes:');
      log('- Repository not public (must be public).');
      log('- GitHub rate-limited API for your IP (rare).');
      log('- Page HTML structure changed or content blocked by GitHub for automated fetch.');
      log('- Filenames contain unusual characters that break parsing.');
      log('');
      log('Please paste the full console output (above) here or allow me to commit a small debug file to your repo.');
      return;
    }

    const list = parseResult.list;
    log('> Page parse produced ' + list.length + ' candidate file(s).');
    filesTbody.innerHTML = '';
    for(let i=0;i<list.length;i++){
      const f = list[i];
      const row = document.createElement('tr');
      row.innerHTML = `<td>${i+1}</td><td>${f.name}</td><td style="word-break:break-all">${f.raw}</td><td>checking..</td>`;
      filesTbody.appendChild(row);
    }
    // check each raw URL
    for(let i=0;i<list.length;i++){
      const f = list[i];
      const res = await checkUrl(f.raw);
      const tr = filesTbody.children[i];
      tr.children[3].textContent = res.ok ? ('OK ' + (res.status || '')) : ('ERROR: ' + (res.status || res.error || 'unknown'));
    }
    summary.textContent = 'Loaded from HTML parse: ' + list.length + ' file(s).';
    resultArea.style.display = '';
    log('=== Diagnostics finished ===');
  }

  runBtn.addEventListener('click', run);
  copyBtn.addEventListener('click', ()=> {
    navigator.clipboard.writeText(logEl.textContent).then(()=> alert('Diagnostics copied to clipboard'), (e)=> alert('Copy failed: '+ e));
  });

})();
</script>
</body>
</html>
